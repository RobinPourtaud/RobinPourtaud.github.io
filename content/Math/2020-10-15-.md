---
title: Approximation de Pi avec la méthode de Monte-Carlo
author: Robin Pourtaud
type: post
date: 1970-01-01T00:00:00+00:00
draft: true
url: /?p=4689
rank_math_seo_score:
  - "17"
rank_math_internal_links_processed:
  - "1"
ampforwp-amp-on-off:
  - default
rank_math_primary_category:
  - "8"
categories:
  - Informatique
tags:
  - Matplotlib
  - Python

---
Si on vous donnait une fonction qui vous permettait d&rsquo;obtenir un nombre entre 0 et 1 aléatoirement, auriez-vous pu imaginer qu&rsquo;il était possible de calculer PI à partir de celle-ci ? 

## En théorie : 

Appelons une fonction sans paramètre « r » permettant d&rsquo;obtenir ce fameux nombre aléatoire entre 0 et 1. Cette fonction, donne évidement des résultats distribué uniformément.

Prenons un espace orthonormé tel que chaque point est défini par (r(),r()). 

Par exemple (0.5, 0.1) 

L&rsquo;aire d&rsquo;un disque est définie par : A = \pi R^2



## En pratique : 

<pre class="wp-block-code" aria-describedby="shcb-language-5" data-shcb-language-name="Python" data-shcb-language-slug="python"><div>
  <code class="hljs language-python">&lt;span class="hljs-keyword">import&lt;/span> numpy.random &lt;span class="hljs-keyword">as&lt;/span> rd
  &lt;span class="hljs-keyword">import&lt;/span> matplotlib.pyplot &lt;span class="hljs-keyword">as&lt;/span> plt
  
  &lt;span class="hljs-function">&lt;span class="hljs-keyword">def&lt;/span> &lt;span class="hljs-title">evaluatePi&lt;/span>&lt;span class="hljs-params">(n)&lt;/span>:&lt;/span>
    &lt;span class="hljs-comment"># La fonction random(n) donne un array avec n valeurs entre 0 et 1&lt;/span>
    &lt;span class="hljs-comment"># Cependant, nous voulons des valeurs entre -1 et 1 &lt;/span>
    &lt;span class="hljs-comment"># Nous dilatons ce tableau avec "2 *"" en partant de -1 :  &lt;/span>
    x = &lt;span class="hljs-number">2&lt;/span>*rd.random(n)&lt;span class="hljs-number">-1&lt;/span> 
    y = &lt;span class="hljs-number">2&lt;/span>*rd.random(n)&lt;span class="hljs-number">-1&lt;/span>
    
    &lt;span class="hljs-comment"># Nous séparons les points de l'intérieur du cercle de ceux de l'exterieur. &lt;/span>
    &lt;span class="hljs-comment"># Remarquez que normalement la formule de la norme est sqrt(x**2+y**2)&lt;/span>
    &lt;span class="hljs-comment"># Cependant, le cercle étant de taille 1, 1**2 = 1, la racine carré&lt;/span>
    &lt;span class="hljs-comment"># n'est donc pas nécessaire et nous fait économiser une opération.&lt;/span>
    inX,  inY  = x[(x**&lt;span class="hljs-number">2&lt;/span>+y**&lt;span class="hljs-number">2&lt;/span>)&lt;=&lt;span class="hljs-number">1&lt;/span>],y[(x**&lt;span class="hljs-number">2&lt;/span>+y**&lt;span class="hljs-number">2&lt;/span>)&lt;=&lt;span class="hljs-number">1&lt;/span>]
    outX, outY = x[(x**&lt;span class="hljs-number">2&lt;/span>+y**&lt;span class="hljs-number">2&lt;/span>)&gt;&lt;span class="hljs-number">1&lt;/span>],y[(x**&lt;span class="hljs-number">2&lt;/span>+y**&lt;span class="hljs-number">2&lt;/span>)&gt;&lt;span class="hljs-number">1&lt;/span>]
  
    pi = (inX.size/(inX.size+outX.size))*&lt;span class="hljs-number">4&lt;/span>
  
    fig,ax = plt.subplots() 
    ax.set_title(&lt;span class="hljs-string">'n = '&lt;/span> + str(n) + &lt;span class="hljs-string">', pi = '&lt;/span> + str(pi))
    ax.scatter(inX, inY, c=&lt;span class="hljs-string">'g'&lt;/span>)
    ax.scatter(outX, outY, c=&lt;span class="hljs-string">'b'&lt;/span>)
    ax.set_aspect(aspect=&lt;span class="hljs-string">'equal'&lt;/span>)
    fig.show()
    &lt;span class="hljs-keyword">return&lt;/span> pi </code>
</div>

<small class="shcb-language" id="shcb-language-5"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Python</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">python</span><span class="shcb-language__paren">)</span></small></pre>

Après une attente de plusieurs minutes, pour n = 1e8, nous obtenons une valeur pour pi de 3.14145472 ainsi que ce magnifique disque : 

<div class="wp-block-image">
  <figure class="aligncenter size-large is-resized"><img loading="lazy" src="https://keskec.fr/wp-content/uploads/2020/10/image.png" alt="" class="wp-image-4694" width="389" height="265" srcset="https://keskec.fr/wp-content/uploads/2020/10/image.png 995w, https://keskec.fr/wp-content/uploads/2020/10/image-300x204.png 300w, https://keskec.fr/wp-content/uploads/2020/10/image-768x523.png 768w" sizes="(max-width: 389px) 100vw, 389px" /></figure>
</div>

## Limite de Python : 

En ayant exécuté ce code en Python, vous avez sans doute remarqué que pour obtenir rien que 4 décimal correcte, il était nécessaire de donner en entrée une très grande valeurs de n.  
De plus, il faut tout de même prendre en compte que la fonction python « rand », bien que très précise et très uniforme, ne peut l&rsquo;être totalement

## Solution : 

Bien qu&rsquo;en théorie, la méthode de Monte-Carlo semble fonctionné relativement bien, il existe de nombreux moyen de calculer PI plus précisément et plus efficacement 

## Sources : 

  1. [Can you solve my favorite interview question? (math + cs) &#8211; Joma Tech][1]{.rank-math-link}
  2. [Can a Monte Carlo pi calculation be used for a world record?][2]

 [1]: https://www.youtube.com/watch?v=pvimAM_SLic
 [2]: https://stackoverflow.com/questions/18139934/can-a-monte-carlo-pi-calculation-be-used-for-a-world-record