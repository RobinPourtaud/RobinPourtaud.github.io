---
title: Algorithme de Rem
author: Robin Pourtaud
type: post
date: 1970-01-01T00:00:00+00:00
draft: true
url: /?p=4916
rank_math_seo_score:
  - "65"
rank_math_primary_category:
  - "8"
ads-for-wp-visibility:
  - show
rank_math_internal_links_processed:
  - "1"
ampforwp-amp-on-off:
  - default
rank_math_focus_keyword:
  - rem
categories:
  - Informatique

---
Rem proposa en 1976 un algorithme de compression de classe-union 

## L&rsquo;algorithme : 

Soit x et y, deux élément d&rsquo;un arbre, défini par la table des parents « p ». 

Retrouvez ci-dessous l&rsquo;algorithme original de Rem implémenté en Python : 

<pre class="wp-block-code" aria-describedby="shcb-language-6" data-shcb-language-name="Python" data-shcb-language-slug="python"><div>
  <code class="hljs language-python">&lt;span class="hljs-function">&lt;span class="hljs-keyword">def&lt;/span> &lt;span class="hljs-title">RemSP&lt;/span>&lt;span class="hljs-params">(i, j)&lt;/span>:&lt;/span> &lt;span class="hljs-comment"># avec p un tableau &lt;/span>
    &lt;span class="hljs-keyword">while&lt;/span> p[i] != p[j]:
      &lt;span class="hljs-keyword">if&lt;/span> p[i] &lt; p[j]: 
        &lt;span class="hljs-keyword">if&lt;/span> p[i] == &lt;span class="hljs-string">'_'&lt;/span> : 
          p[i] = p[j]
          &lt;span class="hljs-keyword">break&lt;/span>
        k = p[i]
        p[i] = p[j]
        i = k
      &lt;span class="hljs-keyword">else&lt;/span>: 
        &lt;span class="hljs-keyword">if&lt;/span> p[j] == &lt;span class="hljs-string">'_'&lt;/span> : 
          p[j] = p[i]
          &lt;span class="hljs-keyword">break&lt;/span>
        k = p[j]
        p[j] = p[i]
        j = k</code>
</div>

<small class="shcb-language" id="shcb-language-6"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Python</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">python</span><span class="shcb-language__paren">)</span></small></pre>

## Complexité temporelle : 

La complexité temporelle de l&rsquo;algorithme de Rem est $O(m log_{2+\frac{m}{n}} n)$ avec : 

  * m : 
  * n : 

Vous pouvez retrouvez la démonstration dans la premié

## Exemple : 

Afin d&rsquo;illustrer la méthode de Rem, je vous propose de prendre pour l&rsquo;arbre ci-dessous, **RemSP(6,3)**. 

### Table des parents avant :<figure class="wp-block-table">

<table class="has-fixed-layout">
  <tr>
    <td>
    </td>
    
    <td>
      1
    </td>
    
    <td>
      1
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
  
  <tr>
    <td>
    </td>
    
    <td>
      2
    </td>
    
    <td>
      3
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
    </td>
  </tr>
</table></figure> 

### Arbre avant : 

<div class="wp-block-image">
  <figure class="aligncenter size-large is-resized"><img loading="lazy" src="https://keskec.fr/wp-content/uploads/2020/12/image-33.png" alt="" class="wp-image-5112" width="201" height="160" srcset="https://keskec.fr/wp-content/uploads/2020/12/image-33.png 427w, https://keskec.fr/wp-content/uploads/2020/12/image-33-300x239.png 300w" sizes="(max-width: 201px) 100vw, 201px" /></figure>
</div>



## Sources : 

  1. [An Experimental Evaluation of Union-Find Algorithms for the Disjoint-Set Data Structure][1]{.rank-math-link}
  2. https://seriouscomputerist.atariverse.com/media/pdf/book/Discipline%20of%20Programming.pdf
  3. https://www.researchgate.net/publication/220430653\_Worst-case\_Analysis\_of\_Set\_Union\_Algorithms

 [1]: https://bora.uib.no/bora-xmlui/bitstream/handle/1956/5118/Dr.thesis_Mostofa_Ali_Patwary.pdf?sequence=1&isAllowed=y